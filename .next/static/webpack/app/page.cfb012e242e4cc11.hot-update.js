"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/firebase.ts":
/*!*************************!*\
  !*** ./lib/firebase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: () => (/* binding */ auth),\n/* harmony export */   createApplication: () => (/* binding */ createApplication),\n/* harmony export */   createEvent: () => (/* binding */ createEvent),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   debugCollections: () => (/* binding */ debugCollections),\n/* harmony export */   deleteEvent: () => (/* binding */ deleteEvent),\n/* harmony export */   getApplicationsByEvent: () => (/* binding */ getApplicationsByEvent),\n/* harmony export */   getApplicationsByUser: () => (/* binding */ getApplicationsByUser),\n/* harmony export */   getEvents: () => (/* binding */ getEvents),\n/* harmony export */   getEventsByOwner: () => (/* binding */ getEventsByOwner),\n/* harmony export */   storage: () => (/* binding */ storage),\n/* harmony export */   updateApplicationStatus: () => (/* binding */ updateApplicationStatus),\n/* harmony export */   updateEvent: () => (/* binding */ updateEvent)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n\nconst firebaseConfig = {\n    apiKey: \"AIzaSyCiJFSq3_sy4wDN2QncaNyqO1MlSmtDn2Q\",\n    authDomain: \"volunteer-a61d3.firebaseapp.com\",\n    projectId: \"volunteer-a61d3\",\n    storageBucket: \"volunteer-a61d3.firebasestorage.app\",\n    messagingSenderId: \"783753586865\",\n    appId: \"1:783753586865:web:84a3f071e33a4934da9a90\",\n    measurementId: \"G-F2W8TS7GB9\"\n};\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)(app);\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_3__.getStorage)(app);\n// Helper function to convert Firestore timestamps\nconst convertTimestamp = (data)=>{\n    const converted = {\n        ...data\n    };\n    Object.keys(converted).forEach((key)=>{\n        if (converted[key] instanceof firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp) {\n            converted[key] = converted[key].toDate().toISOString();\n        }\n    });\n    return converted;\n};\n// Event functions\nconst createEvent = async (eventData)=>{\n    try {\n        console.log('Creating event with data:', eventData);\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), {\n            ...eventData,\n            createdAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now(),\n            updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log('Event created with ID:', docRef.id);\n        return docRef;\n    } catch (error) {\n        console.error('Error creating event:', error);\n        throw error;\n    }\n};\nconst getEvents = async ()=>{\n    try {\n        console.log('Fetching all events...');\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)('createdAt', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const events = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...convertTimestamp(doc.data())\n            }));\n        console.log('Events fetched:', events.length);\n        return events;\n    } catch (error) {\n        console.error('Error fetching events:', error);\n        throw error;\n    }\n};\nconst getEventsByOwner = async (ownerId)=>{\n    try {\n        console.log('Fetching events for owner:', ownerId);\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('ownerId', '==', ownerId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)('createdAt', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const events = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...convertTimestamp(doc.data())\n            }));\n        console.log(\"Events fetched for owner \".concat(ownerId, \":\"), events.length);\n        return events;\n    } catch (error) {\n        console.error('Error fetching events by owner:', error);\n        // If the error is due to missing index, try without orderBy\n        if (error.code === 'failed-precondition') {\n            console.log('Retrying without orderBy due to missing index...');\n            try {\n                const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('ownerId', '==', ownerId));\n                const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n                const events = querySnapshot.docs.map((doc)=>({\n                        id: doc.id,\n                        ...convertTimestamp(doc.data())\n                    }));\n                // Sort manually by createdAt\n                events.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n                console.log(\"Events fetched for owner \".concat(ownerId, \" (without index):\"), events.length);\n                return events;\n            } catch (retryError) {\n                console.error('Retry failed:', retryError);\n                throw retryError;\n            }\n        }\n        throw error;\n    }\n};\nconst updateEvent = async (eventId, updates)=>{\n    try {\n        console.log(\"Updating event \".concat(eventId, \":\"), updates);\n        const eventRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, 'events', eventId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(eventRef, {\n            ...updates,\n            updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log(\"Event \".concat(eventId, \" updated successfully\"));\n    } catch (error) {\n        console.error('Error updating event:', error);\n        throw error;\n    }\n};\nconst deleteEvent = async (eventId)=>{\n    try {\n        console.log('Deleting event:', eventId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, 'events', eventId));\n        console.log(\"Event \".concat(eventId, \" deleted successfully\"));\n    } catch (error) {\n        console.error('Error deleting event:', error);\n        throw error;\n    }\n};\n// Application functions\nconst createApplication = async (applicationData)=>{\n    try {\n        console.log('Creating application with data:', applicationData);\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), {\n            ...applicationData,\n            status: 'pending',\n            createdAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log('Application created with ID:', docRef.id);\n        return docRef;\n    } catch (error) {\n        console.error('Error creating application:', error);\n        throw error;\n    }\n};\nconst getApplicationsByEvent = async (eventId)=>{\n    try {\n        console.log('Fetching applications for event:', eventId);\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('eventId', '==', eventId));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const applications = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...convertTimestamp(doc.data())\n            }));\n        console.log(\"Applications fetched for event \".concat(eventId, \":\"), applications.length);\n        return applications;\n    } catch (error) {\n        console.error('Error fetching applications by event:', error);\n        throw error;\n    }\n};\nconst getApplicationsByUser = async (userId)=>{\n    try {\n        console.log('Fetching applications for user:', userId);\n        // First try with orderBy\n        try {\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)('createdAt', 'desc'));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n            const applications = querySnapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...convertTimestamp(doc.data())\n                }));\n            console.log(\"Applications fetched for user \".concat(userId, \":\"), applications.length);\n            return applications;\n        } catch (indexError) {\n            // If index doesn't exist, fetch without orderBy and sort manually\n            if (indexError.code === 'failed-precondition') {\n                console.log('Index not found, fetching without orderBy and sorting manually...');\n                const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('userId', '==', userId));\n                const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n                const applications = querySnapshot.docs.map((doc)=>({\n                        id: doc.id,\n                        ...convertTimestamp(doc.data())\n                    }));\n                // Sort manually by createdAt (newest first)\n                applications.sort((a, b)=>{\n                    const dateA = new Date(a.createdAt).getTime();\n                    const dateB = new Date(b.createdAt).getTime();\n                    return dateB - dateA;\n                });\n                console.log(\"Applications fetched for user \".concat(userId, \" (manual sort):\"), applications.length);\n                return applications;\n            }\n            throw indexError;\n        }\n    } catch (error) {\n        console.error('Error fetching applications by user:', error);\n        throw error;\n    }\n};\nconst updateApplicationStatus = async (applicationId, status)=>{\n    try {\n        console.log(\"Updating application \".concat(applicationId, \" status to:\"), status);\n        const applicationRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, 'applications', applicationId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(applicationRef, {\n            status,\n            updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log(\"Application \".concat(applicationId, \" status updated successfully\"));\n    } catch (error) {\n        console.error('Error updating application status:', error);\n        throw error;\n    }\n};\n// Debug function to check collections\nconst debugCollections = async ()=>{\n    try {\n        console.log('=== DEBUG: Checking collections ===');\n        // Check events collection\n        const eventsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'));\n        console.log('Events collection size:', eventsSnapshot.size);\n        eventsSnapshot.docs.forEach((doc)=>{\n            console.log('Event:', doc.id, doc.data());\n        });\n        // Check applications collection\n        const applicationsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'));\n        console.log('Applications collection size:', applicationsSnapshot.size);\n        applicationsSnapshot.docs.forEach((doc)=>{\n            console.log('Application:', doc.id, doc.data());\n        });\n        console.log('=== END DEBUG ===');\n    } catch (error) {\n        console.error('Debug error:', error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7UUFDcEQsTUFBTUE7SUFDUjtBQUNGLEVBQUM7QUFFRCxzQ0FBc0M7QUFDL0IsTUFBTW1DLG1CQUFtQjtJQUM5QixJQUFJO1FBQ0YxQyxRQUFRQyxHQUFHLENBQUM7UUFFWiwwQkFBMEI7UUFDMUIsTUFBTTBDLGlCQUFpQixNQUFNM0UsMkRBQU9BLENBQUNGLDhEQUFVQSxDQUFDcUIsSUFBSTtRQUNwRGEsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQjBDLGVBQWVDLElBQUk7UUFDMURELGVBQWUvQixJQUFJLENBQUNsQixPQUFPLENBQUN6QixDQUFBQTtZQUMxQitCLFFBQVFDLEdBQUcsQ0FBQyxVQUFVaEMsSUFBSXFDLEVBQUUsRUFBRXJDLElBQUlxQixJQUFJO1FBQ3hDO1FBRUEsZ0NBQWdDO1FBQ2hDLE1BQU11RCx1QkFBdUIsTUFBTTdFLDJEQUFPQSxDQUFDRiw4REFBVUEsQ0FBQ3FCLElBQUk7UUFDMURhLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUM0QyxxQkFBcUJELElBQUk7UUFDdEVDLHFCQUFxQmpDLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ3pCLENBQUFBO1lBQ2hDK0IsUUFBUUMsR0FBRyxDQUFDLGdCQUFnQmhDLElBQUlxQyxFQUFFLEVBQUVyQyxJQUFJcUIsSUFBSTtRQUM5QztRQUVBVSxRQUFRQyxHQUFHLENBQUM7SUFDZCxFQUFFLE9BQU9NLE9BQU87UUFDZFAsUUFBUU8sS0FBSyxDQUFDLGdCQUFnQkE7SUFDaEM7QUFDRixFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVTRVJcXERlc2t0b3BcXHZvbHVudGVlcmluZy13ZWJzaXRlXFxsaWJcXGZpcmViYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXRpYWxpemVBcHAgfSBmcm9tICdmaXJlYmFzZS9hcHAnXG5pbXBvcnQgeyBnZXRBdXRoIH0gZnJvbSAnZmlyZWJhc2UvYXV0aCdcbmltcG9ydCB7IFxuICBnZXRGaXJlc3RvcmUsIFxuICBjb2xsZWN0aW9uLCBcbiAgYWRkRG9jLCBcbiAgZ2V0RG9jcywgXG4gIGRvYywgXG4gIHVwZGF0ZURvYywgXG4gIGRlbGV0ZURvYywgXG4gIHF1ZXJ5LCBcbiAgd2hlcmUsIFxuICBvcmRlckJ5LFxuICBUaW1lc3RhbXAsXG4gIERvY3VtZW50RGF0YSxcbiAgUXVlcnlEb2N1bWVudFNuYXBzaG90XG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSdcbmltcG9ydCB7IGdldFN0b3JhZ2UgfSBmcm9tICdmaXJlYmFzZS9zdG9yYWdlJ1xuXG5jb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcbiAgYXBpS2V5OiBcIkFJemFTeUNpSkZTcTNfc3k0d0ROMlFuY2FOeXFPMU1sU210RG4yUVwiLFxuICBhdXRoRG9tYWluOiBcInZvbHVudGVlci1hNjFkMy5maXJlYmFzZWFwcC5jb21cIixcbiAgcHJvamVjdElkOiBcInZvbHVudGVlci1hNjFkM1wiLFxuICBzdG9yYWdlQnVja2V0OiBcInZvbHVudGVlci1hNjFkMy5maXJlYmFzZXN0b3JhZ2UuYXBwXCIsXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBcIjc4Mzc1MzU4Njg2NVwiLFxuICBhcHBJZDogXCIxOjc4Mzc1MzU4Njg2NTp3ZWI6ODRhM2YwNzFlMzNhNDkzNGRhOWE5MFwiLFxuICBtZWFzdXJlbWVudElkOiBcIkctRjJXOFRTN0dCOVwiXG59O1xuXG5jb25zdCBhcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKVxuZXhwb3J0IGNvbnN0IGF1dGggPSBnZXRBdXRoKGFwcClcbmV4cG9ydCBjb25zdCBkYiA9IGdldEZpcmVzdG9yZShhcHApXG5leHBvcnQgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoYXBwKVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBGaXJlc3RvcmUgdGltZXN0YW1wc1xuY29uc3QgY29udmVydFRpbWVzdGFtcCA9IChkYXRhOiBEb2N1bWVudERhdGEpID0+IHtcbiAgY29uc3QgY29udmVydGVkID0geyAuLi5kYXRhIH1cbiAgT2JqZWN0LmtleXMoY29udmVydGVkKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGNvbnZlcnRlZFtrZXldIGluc3RhbmNlb2YgVGltZXN0YW1wKSB7XG4gICAgICBjb252ZXJ0ZWRba2V5XSA9IGNvbnZlcnRlZFtrZXldLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9XG4gIH0pXG4gIHJldHVybiBjb252ZXJ0ZWRcbn1cblxuLy8gRXZlbnQgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgY3JlYXRlRXZlbnQgPSBhc3luYyAoZXZlbnREYXRhOiBhbnkpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgZXZlbnQgd2l0aCBkYXRhOicsIGV2ZW50RGF0YSlcbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ2V2ZW50cycpLCB7XG4gICAgICAuLi5ldmVudERhdGEsXG4gICAgICBjcmVhdGVkQXQ6IFRpbWVzdGFtcC5ub3coKSxcbiAgICAgIHVwZGF0ZWRBdDogVGltZXN0YW1wLm5vdygpXG4gICAgfSlcbiAgICBjb25zb2xlLmxvZygnRXZlbnQgY3JlYXRlZCB3aXRoIElEOicsIGRvY1JlZi5pZClcbiAgICByZXR1cm4gZG9jUmVmXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgZXZlbnQ6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0RXZlbnRzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhbGwgZXZlbnRzLi4uJylcbiAgICBjb25zdCBxID0gcXVlcnkoY29sbGVjdGlvbihkYiwgJ2V2ZW50cycpLCBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpKVxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpXG4gICAgY29uc3QgZXZlbnRzID0gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAuLi5jb252ZXJ0VGltZXN0YW1wKGRvYy5kYXRhKCkpXG4gICAgfSkpXG4gICAgY29uc29sZS5sb2coJ0V2ZW50cyBmZXRjaGVkOicsIGV2ZW50cy5sZW5ndGgpXG4gICAgcmV0dXJuIGV2ZW50c1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV2ZW50czonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRFdmVudHNCeU93bmVyID0gYXN5bmMgKG93bmVySWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBldmVudHMgZm9yIG93bmVyOicsIG93bmVySWQpXG4gICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgY29sbGVjdGlvbihkYiwgJ2V2ZW50cycpLCBcbiAgICAgIHdoZXJlKCdvd25lcklkJywgJz09Jywgb3duZXJJZCksXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgKVxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpXG4gICAgY29uc3QgZXZlbnRzID0gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAuLi5jb252ZXJ0VGltZXN0YW1wKGRvYy5kYXRhKCkpXG4gICAgfSkpXG4gICAgY29uc29sZS5sb2coYEV2ZW50cyBmZXRjaGVkIGZvciBvd25lciAke293bmVySWR9OmAsIGV2ZW50cy5sZW5ndGgpXG4gICAgcmV0dXJuIGV2ZW50c1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV2ZW50cyBieSBvd25lcjonLCBlcnJvcilcbiAgICAvLyBJZiB0aGUgZXJyb3IgaXMgZHVlIHRvIG1pc3NpbmcgaW5kZXgsIHRyeSB3aXRob3V0IG9yZGVyQnlcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ2ZhaWxlZC1wcmVjb25kaXRpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZygnUmV0cnlpbmcgd2l0aG91dCBvcmRlckJ5IGR1ZSB0byBtaXNzaW5nIGluZGV4Li4uJylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAnZXZlbnRzJyksIFxuICAgICAgICAgIHdoZXJlKCdvd25lcklkJywgJz09Jywgb3duZXJJZClcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKVxuICAgICAgICBjb25zdCBldmVudHMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgICAgLi4uY29udmVydFRpbWVzdGFtcChkb2MuZGF0YSgpKVxuICAgICAgICB9KSlcbiAgICAgICAgLy8gU29ydCBtYW51YWxseSBieSBjcmVhdGVkQXRcbiAgICAgICAgZXZlbnRzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIuY3JlYXRlZEF0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmNyZWF0ZWRBdCkuZ2V0VGltZSgpKVxuICAgICAgICBjb25zb2xlLmxvZyhgRXZlbnRzIGZldGNoZWQgZm9yIG93bmVyICR7b3duZXJJZH0gKHdpdGhvdXQgaW5kZXgpOmAsIGV2ZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBldmVudHNcbiAgICAgIH0gY2F0Y2ggKHJldHJ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUmV0cnkgZmFpbGVkOicsIHJldHJ5RXJyb3IpXG4gICAgICAgIHRocm93IHJldHJ5RXJyb3JcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlRXZlbnQgPSBhc3luYyAoZXZlbnRJZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgZXZlbnQgJHtldmVudElkfTpgLCB1cGRhdGVzKVxuICAgIGNvbnN0IGV2ZW50UmVmID0gZG9jKGRiLCAnZXZlbnRzJywgZXZlbnRJZClcbiAgICBhd2FpdCB1cGRhdGVEb2MoZXZlbnRSZWYsIHtcbiAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICB1cGRhdGVkQXQ6IFRpbWVzdGFtcC5ub3coKVxuICAgIH0pXG4gICAgY29uc29sZS5sb2coYEV2ZW50ICR7ZXZlbnRJZH0gdXBkYXRlZCBzdWNjZXNzZnVsbHlgKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGV2ZW50OicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUV2ZW50ID0gYXN5bmMgKGV2ZW50SWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdEZWxldGluZyBldmVudDonLCBldmVudElkKVxuICAgIGF3YWl0IGRlbGV0ZURvYyhkb2MoZGIsICdldmVudHMnLCBldmVudElkKSlcbiAgICBjb25zb2xlLmxvZyhgRXZlbnQgJHtldmVudElkfSBkZWxldGVkIHN1Y2Nlc3NmdWxseWApXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgZXZlbnQ6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBBcHBsaWNhdGlvbiBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBjcmVhdGVBcHBsaWNhdGlvbiA9IGFzeW5jIChhcHBsaWNhdGlvbkRhdGE6IGFueSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBhcHBsaWNhdGlvbiB3aXRoIGRhdGE6JywgYXBwbGljYXRpb25EYXRhKVxuICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCAnYXBwbGljYXRpb25zJyksIHtcbiAgICAgIC4uLmFwcGxpY2F0aW9uRGF0YSxcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgY3JlYXRlZEF0OiBUaW1lc3RhbXAubm93KClcbiAgICB9KVxuICAgIGNvbnNvbGUubG9nKCdBcHBsaWNhdGlvbiBjcmVhdGVkIHdpdGggSUQ6JywgZG9jUmVmLmlkKVxuICAgIHJldHVybiBkb2NSZWZcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBhcHBsaWNhdGlvbjonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRBcHBsaWNhdGlvbnNCeUV2ZW50ID0gYXN5bmMgKGV2ZW50SWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhcHBsaWNhdGlvbnMgZm9yIGV2ZW50OicsIGV2ZW50SWQpXG4gICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgY29sbGVjdGlvbihkYiwgJ2FwcGxpY2F0aW9ucycpLFxuICAgICAgd2hlcmUoJ2V2ZW50SWQnLCAnPT0nLCBldmVudElkKVxuICAgIClcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKVxuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICBpZDogZG9jLmlkLFxuICAgICAgLi4uY29udmVydFRpbWVzdGFtcChkb2MuZGF0YSgpKVxuICAgIH0pKVxuICAgIGNvbnNvbGUubG9nKGBBcHBsaWNhdGlvbnMgZmV0Y2hlZCBmb3IgZXZlbnQgJHtldmVudElkfTpgLCBhcHBsaWNhdGlvbnMubGVuZ3RoKVxuICAgIHJldHVybiBhcHBsaWNhdGlvbnNcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhcHBsaWNhdGlvbnMgYnkgZXZlbnQ6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25zQnlVc2VyID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIGFwcGxpY2F0aW9ucyBmb3IgdXNlcjonLCB1c2VySWQpXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggb3JkZXJCeVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICAgIGNvbGxlY3Rpb24oZGIsICdhcHBsaWNhdGlvbnMnKSxcbiAgICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXG4gICAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJylcbiAgICAgIClcbiAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpXG4gICAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAuLi5jb252ZXJ0VGltZXN0YW1wKGRvYy5kYXRhKCkpXG4gICAgICB9KSlcbiAgICAgIGNvbnNvbGUubG9nKGBBcHBsaWNhdGlvbnMgZmV0Y2hlZCBmb3IgdXNlciAke3VzZXJJZH06YCwgYXBwbGljYXRpb25zLmxlbmd0aClcbiAgICAgIHJldHVybiBhcHBsaWNhdGlvbnNcbiAgICB9IGNhdGNoIChpbmRleEVycm9yKSB7XG4gICAgICAvLyBJZiBpbmRleCBkb2Vzbid0IGV4aXN0LCBmZXRjaCB3aXRob3V0IG9yZGVyQnkgYW5kIHNvcnQgbWFudWFsbHlcbiAgICAgIGlmIChpbmRleEVycm9yLmNvZGUgPT09ICdmYWlsZWQtcHJlY29uZGl0aW9uJykge1xuICAgICAgICBjb25zb2xlLmxvZygnSW5kZXggbm90IGZvdW5kLCBmZXRjaGluZyB3aXRob3V0IG9yZGVyQnkgYW5kIHNvcnRpbmcgbWFudWFsbHkuLi4nKVxuICAgICAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICAgICAgY29sbGVjdGlvbihkYiwgJ2FwcGxpY2F0aW9ucycpLFxuICAgICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSlcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAgIC4uLmNvbnZlcnRUaW1lc3RhbXAoZG9jLmRhdGEoKSlcbiAgICAgICAgfSkpXG4gICAgICAgIFxuICAgICAgICAvLyBTb3J0IG1hbnVhbGx5IGJ5IGNyZWF0ZWRBdCAobmV3ZXN0IGZpcnN0KVxuICAgICAgICBhcHBsaWNhdGlvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGVBID0gbmV3IERhdGUoYS5jcmVhdGVkQXQpLmdldFRpbWUoKVxuICAgICAgICAgIGNvbnN0IGRhdGVCID0gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKVxuICAgICAgICAgIHJldHVybiBkYXRlQiAtIGRhdGVBXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgQXBwbGljYXRpb25zIGZldGNoZWQgZm9yIHVzZXIgJHt1c2VySWR9IChtYW51YWwgc29ydCk6YCwgYXBwbGljYXRpb25zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uc1xuICAgICAgfVxuICAgICAgdGhyb3cgaW5kZXhFcnJvclxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhcHBsaWNhdGlvbnMgYnkgdXNlcjonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVBcHBsaWNhdGlvblN0YXR1cyA9IGFzeW5jIChhcHBsaWNhdGlvbklkOiBzdHJpbmcsIHN0YXR1czogJ2FwcHJvdmVkJyB8ICdkZWNsaW5lZCcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgYXBwbGljYXRpb24gJHthcHBsaWNhdGlvbklkfSBzdGF0dXMgdG86YCwgc3RhdHVzKVxuICAgIGNvbnN0IGFwcGxpY2F0aW9uUmVmID0gZG9jKGRiLCAnYXBwbGljYXRpb25zJywgYXBwbGljYXRpb25JZClcbiAgICBhd2FpdCB1cGRhdGVEb2MoYXBwbGljYXRpb25SZWYsIHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIHVwZGF0ZWRBdDogVGltZXN0YW1wLm5vdygpXG4gICAgfSlcbiAgICBjb25zb2xlLmxvZyhgQXBwbGljYXRpb24gJHthcHBsaWNhdGlvbklkfSBzdGF0dXMgdXBkYXRlZCBzdWNjZXNzZnVsbHlgKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGFwcGxpY2F0aW9uIHN0YXR1czonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIERlYnVnIGZ1bmN0aW9uIHRvIGNoZWNrIGNvbGxlY3Rpb25zXG5leHBvcnQgY29uc3QgZGVidWdDb2xsZWN0aW9ucyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnPT09IERFQlVHOiBDaGVja2luZyBjb2xsZWN0aW9ucyA9PT0nKVxuICAgIFxuICAgIC8vIENoZWNrIGV2ZW50cyBjb2xsZWN0aW9uXG4gICAgY29uc3QgZXZlbnRzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxlY3Rpb24oZGIsICdldmVudHMnKSlcbiAgICBjb25zb2xlLmxvZygnRXZlbnRzIGNvbGxlY3Rpb24gc2l6ZTonLCBldmVudHNTbmFwc2hvdC5zaXplKVxuICAgIGV2ZW50c1NuYXBzaG90LmRvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ0V2ZW50OicsIGRvYy5pZCwgZG9jLmRhdGEoKSlcbiAgICB9KVxuICAgIFxuICAgIC8vIENoZWNrIGFwcGxpY2F0aW9ucyBjb2xsZWN0aW9uXG4gICAgY29uc3QgYXBwbGljYXRpb25zU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxlY3Rpb24oZGIsICdhcHBsaWNhdGlvbnMnKSlcbiAgICBjb25zb2xlLmxvZygnQXBwbGljYXRpb25zIGNvbGxlY3Rpb24gc2l6ZTonLCBhcHBsaWNhdGlvbnNTbmFwc2hvdC5zaXplKVxuICAgIGFwcGxpY2F0aW9uc1NuYXBzaG90LmRvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ0FwcGxpY2F0aW9uOicsIGRvYy5pZCwgZG9jLmRhdGEoKSlcbiAgICB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCc9PT0gRU5EIERFQlVHID09PScpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRGVidWcgZXJyb3I6JywgZXJyb3IpXG4gIH1cbn0iXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEF1dGgiLCJnZXRGaXJlc3RvcmUiLCJjb2xsZWN0aW9uIiwiYWRkRG9jIiwiZ2V0RG9jcyIsImRvYyIsInVwZGF0ZURvYyIsImRlbGV0ZURvYyIsInF1ZXJ5Iiwid2hlcmUiLCJvcmRlckJ5IiwiVGltZXN0YW1wIiwiZ2V0U3RvcmFnZSIsImZpcmViYXNlQ29uZmlnIiwiYXBpS2V5IiwiYXV0aERvbWFpbiIsInByb2plY3RJZCIsInN0b3JhZ2VCdWNrZXQiLCJtZXNzYWdpbmdTZW5kZXJJZCIsImFwcElkIiwibWVhc3VyZW1lbnRJZCIsImFwcCIsImF1dGgiLCJkYiIsInN0b3JhZ2UiLCJjb252ZXJ0VGltZXN0YW1wIiwiZGF0YSIsImNvbnZlcnRlZCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwidG9EYXRlIiwidG9JU09TdHJpbmciLCJjcmVhdGVFdmVudCIsImV2ZW50RGF0YSIsImNvbnNvbGUiLCJsb2ciLCJkb2NSZWYiLCJjcmVhdGVkQXQiLCJub3ciLCJ1cGRhdGVkQXQiLCJpZCIsImVycm9yIiwiZ2V0RXZlbnRzIiwicSIsInF1ZXJ5U25hcHNob3QiLCJldmVudHMiLCJkb2NzIiwibWFwIiwibGVuZ3RoIiwiZ2V0RXZlbnRzQnlPd25lciIsIm93bmVySWQiLCJjb2RlIiwic29ydCIsImEiLCJiIiwiRGF0ZSIsImdldFRpbWUiLCJyZXRyeUVycm9yIiwidXBkYXRlRXZlbnQiLCJldmVudElkIiwidXBkYXRlcyIsImV2ZW50UmVmIiwiZGVsZXRlRXZlbnQiLCJjcmVhdGVBcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uRGF0YSIsInN0YXR1cyIsImdldEFwcGxpY2F0aW9uc0J5RXZlbnQiLCJhcHBsaWNhdGlvbnMiLCJnZXRBcHBsaWNhdGlvbnNCeVVzZXIiLCJ1c2VySWQiLCJpbmRleEVycm9yIiwiZGF0ZUEiLCJkYXRlQiIsInVwZGF0ZUFwcGxpY2F0aW9uU3RhdHVzIiwiYXBwbGljYXRpb25JZCIsImFwcGxpY2F0aW9uUmVmIiwiZGVidWdDb2xsZWN0aW9ucyIsImV2ZW50c1NuYXBzaG90Iiwic2l6ZSIsImFwcGxpY2F0aW9uc1NuYXBzaG90Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firebase.ts\n"));

/***/ })

});