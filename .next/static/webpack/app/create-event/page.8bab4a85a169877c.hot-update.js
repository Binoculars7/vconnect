"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/create-event/page",{

/***/ "(app-pages-browser)/./lib/firebase.ts":
/*!*************************!*\
  !*** ./lib/firebase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: () => (/* binding */ auth),\n/* harmony export */   createApplication: () => (/* binding */ createApplication),\n/* harmony export */   createEvent: () => (/* binding */ createEvent),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   debugCollections: () => (/* binding */ debugCollections),\n/* harmony export */   deleteEvent: () => (/* binding */ deleteEvent),\n/* harmony export */   getApplicationsByEvent: () => (/* binding */ getApplicationsByEvent),\n/* harmony export */   getApplicationsByUser: () => (/* binding */ getApplicationsByUser),\n/* harmony export */   getEvents: () => (/* binding */ getEvents),\n/* harmony export */   getEventsByOwner: () => (/* binding */ getEventsByOwner),\n/* harmony export */   storage: () => (/* binding */ storage),\n/* harmony export */   updateApplicationStatus: () => (/* binding */ updateApplicationStatus),\n/* harmony export */   updateEvent: () => (/* binding */ updateEvent)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n\n\n\n\nconst firebaseConfig = {\n    apiKey: \"AIzaSyCiJFSq3_sy4wDN2QncaNyqO1MlSmtDn2Q\",\n    authDomain: \"volunteer-a61d3.firebaseapp.com\",\n    projectId: \"volunteer-a61d3\",\n    storageBucket: \"volunteer-a61d3.firebasestorage.app\",\n    messagingSenderId: \"783753586865\",\n    appId: \"1:783753586865:web:84a3f071e33a4934da9a90\",\n    measurementId: \"G-F2W8TS7GB9\"\n};\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)(app);\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_3__.getStorage)(app);\n// Helper function to convert Firestore timestamps\n// Replace the existing convertTimestamp function\nconst convertTimestamp = (data)=>{\n    const converted = {\n        ...data\n    };\n    Object.keys(converted).forEach((key)=>{\n        if (converted[key] instanceof firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp) {\n            converted[key] = converted[key].toDate().toISOString();\n        } else if (key === 'createdAt' && !converted[key]) {\n            // Ensure createdAt always has a value\n            converted[key] = new Date().toISOString();\n        }\n    });\n    return converted;\n};\n// Event functions\nconst createEvent = async (eventData)=>{\n    try {\n        console.log('Creating event with data:', eventData);\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), {\n            ...eventData,\n            createdAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now(),\n            updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log('Event created with ID:', docRef.id);\n        return docRef;\n    } catch (error) {\n        console.error('Error creating event:', error);\n        throw error;\n    }\n};\nconst getEvents = async ()=>{\n    try {\n        console.log('Fetching all events...');\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)('createdAt', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const events = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...convertTimestamp(doc.data())\n            }));\n        console.log('Events fetched:', events.length);\n        return events;\n    } catch (error) {\n        console.error('Error fetching events:', error);\n        throw error;\n    }\n};\nconst getEventsByOwner = async (ownerId)=>{\n    try {\n        console.log('Fetching events for owner:', ownerId);\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('ownerId', '==', ownerId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)('createdAt', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const events = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...convertTimestamp(doc.data())\n            }));\n        console.log(\"Events fetched for owner \".concat(ownerId, \":\"), events.length);\n        return events;\n    } catch (error) {\n        console.error('Error fetching events by owner:', error);\n        // Fix: Proper type checking for FirestoreError\n        if (error instanceof Error && 'code' in error && error.code === 'failed-precondition') {\n            console.log('Retrying without orderBy due to missing index...');\n            try {\n                const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('ownerId', '==', ownerId));\n                const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n                const events = querySnapshot.docs.map((doc)=>({\n                        id: doc.id,\n                        ...convertTimestamp(doc.data())\n                    }));\n                // Sort manually by createdAt\n                events.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n                console.log(\"Events fetched for owner \".concat(ownerId, \" (without index):\"), events.length);\n                return events;\n            } catch (retryError) {\n                console.error('Retry failed:', retryError);\n                throw retryError;\n            }\n        }\n        throw error;\n    }\n};\nconst updateEvent = async (eventId, updates)=>{\n    try {\n        console.log(\"Updating event \".concat(eventId, \":\"), updates);\n        const eventRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, 'events', eventId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(eventRef, {\n            ...updates,\n            updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log(\"Event \".concat(eventId, \" updated successfully\"));\n    } catch (error) {\n        console.error('Error updating event:', error);\n        throw error;\n    }\n};\nconst deleteEvent = async (eventId)=>{\n    try {\n        console.log('Deleting event:', eventId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, 'events', eventId));\n        console.log(\"Event \".concat(eventId, \" deleted successfully\"));\n    } catch (error) {\n        console.error('Error deleting event:', error);\n        throw error;\n    }\n};\n// Application functions\nconst createApplication = async (applicationData)=>{\n    try {\n        console.log('Creating application with data:', applicationData);\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), {\n            ...applicationData,\n            status: 'pending',\n            createdAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log('Application created with ID:', docRef.id);\n        return docRef;\n    } catch (error) {\n        console.error('Error creating application:', error);\n        throw error;\n    }\n};\nconst getApplicationsByEvent = async (eventId)=>{\n    try {\n        console.log('Fetching applications for event:', eventId);\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('eventId', '==', eventId));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const applications = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...convertTimestamp(doc.data())\n            }));\n        console.log(\"Applications fetched for event \".concat(eventId, \":\"), applications.length);\n        return applications;\n    } catch (error) {\n        console.error('Error fetching applications by event:', error);\n        throw error;\n    }\n};\nconst getApplicationsByUser = async (userId)=>{\n    try {\n        console.log('Fetching applications for user:', userId);\n        // First try with orderBy\n        try {\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)('createdAt', 'desc'));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n            const applications = querySnapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...convertTimestamp(doc.data())\n                }));\n            console.log(\"Applications fetched for user \".concat(userId, \":\"), applications.length);\n            return applications;\n        } catch (indexError) {\n            // Fix: Proper type checking for FirestoreError\n            if (indexError instanceof Error && 'code' in indexError && indexError.code === 'failed-precondition') {\n                console.log('Index not found, fetching without orderBy and sorting manually...');\n                const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)('userId', '==', userId));\n                const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n                const applications = querySnapshot.docs.map((doc)=>({\n                        id: doc.id,\n                        ...convertTimestamp(doc.data())\n                    }));\n                // Fix: Proper type assertion for date strings\n                applications.sort((a, b)=>{\n                    const dateA = new Date(a.createdAt).getTime();\n                    const dateB = new Date(b.createdAt).getTime();\n                    return dateB - dateA;\n                });\n                console.log(\"Applications fetched for user \".concat(userId, \" (manual sort):\"), applications.length);\n                return applications;\n            }\n            throw indexError;\n        }\n    } catch (error) {\n        console.error('Error fetching applications by user:', error);\n        throw error;\n    }\n};\nconst updateApplicationStatus = async (applicationId, status)=>{\n    try {\n        console.log(\"Updating application \".concat(applicationId, \" status to:\"), status);\n        const applicationRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, 'applications', applicationId);\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(applicationRef, {\n            status,\n            updatedAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.Timestamp.now()\n        });\n        console.log(\"Application \".concat(applicationId, \" status updated successfully\"));\n    } catch (error) {\n        console.error('Error updating application status:', error);\n        throw error;\n    }\n};\n// Debug function to check collections\nconst debugCollections = async ()=>{\n    try {\n        console.log('=== DEBUG: Checking collections ===');\n        // Check events collection\n        const eventsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'events'));\n        console.log('Events collection size:', eventsSnapshot.size);\n        eventsSnapshot.docs.forEach((doc)=>{\n            console.log('Event:', doc.id, doc.data());\n        });\n        // Check applications collection\n        const applicationsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, 'applications'));\n        console.log('Applications collection size:', applicationsSnapshot.size);\n        applicationsSnapshot.docs.forEach((doc)=>{\n            console.log('Application:', doc.id, doc.data());\n        });\n        console.log('=== END DEBUG ===');\n    } catch (error) {\n        console.error('Debug error:', error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxnQkFBZ0JzRDtRQUMvQyxNQUFNdkUsNkRBQVNBLENBQUN3RSxnQkFBZ0I7WUFDOUJWO1lBQ0ExQixXQUFXL0IseURBQVNBLENBQUM4QixHQUFHO1FBQzFCO1FBQ0FKLFFBQVFDLEdBQUcsQ0FBQyxlQUE2QixPQUFkdUMsZUFBYztJQUMzQyxFQUFFLE9BQU9qQyxPQUFPO1FBQ2RQLFFBQVFPLEtBQUssQ0FBQyxzQ0FBc0NBO1FBQ3BELE1BQU1BO0lBQ1I7QUFDRixFQUFDO0FBRUQsc0NBQXNDO0FBQy9CLE1BQU1tQyxtQkFBbUI7SUFDOUIsSUFBSTtRQUNGMUMsUUFBUUMsR0FBRyxDQUFDO1FBRVosMEJBQTBCO1FBQzFCLE1BQU0wQyxpQkFBaUIsTUFBTTVFLDJEQUFPQSxDQUFDRiw4REFBVUEsQ0FBQ3FCLElBQUk7UUFDcERjLFFBQVFDLEdBQUcsQ0FBQywyQkFBMkIwQyxlQUFlQyxJQUFJO1FBQzFERCxlQUFlL0IsSUFBSSxDQUFDbkIsT0FBTyxDQUFDekIsQ0FBQUE7WUFDMUJnQyxRQUFRQyxHQUFHLENBQUMsVUFBVWpDLElBQUlzQyxFQUFFLEVBQUV0QyxJQUFJcUIsSUFBSTtRQUN4QztRQUVBLGdDQUFnQztRQUNoQyxNQUFNd0QsdUJBQXVCLE1BQU05RSwyREFBT0EsQ0FBQ0YsOERBQVVBLENBQUNxQixJQUFJO1FBQzFEYyxRQUFRQyxHQUFHLENBQUMsaUNBQWlDNEMscUJBQXFCRCxJQUFJO1FBQ3RFQyxxQkFBcUJqQyxJQUFJLENBQUNuQixPQUFPLENBQUN6QixDQUFBQTtZQUNoQ2dDLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JqQyxJQUFJc0MsRUFBRSxFQUFFdEMsSUFBSXFCLElBQUk7UUFDOUM7UUFFQVcsUUFBUUMsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPTSxPQUFPO1FBQ2RQLFFBQVFPLEtBQUssQ0FBQyxnQkFBZ0JBO0lBQ2hDO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVU0VSXFxEZXNrdG9wXFx2b2x1bnRlZXJpbmctd2Vic2l0ZVxcbGliXFxmaXJlYmFzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbml0aWFsaXplQXBwIH0gZnJvbSAnZmlyZWJhc2UvYXBwJ1xuaW1wb3J0IHsgZ2V0QXV0aCB9IGZyb20gJ2ZpcmViYXNlL2F1dGgnXG5pbXBvcnQgeyBcbiAgZ2V0RmlyZXN0b3JlLCBcbiAgY29sbGVjdGlvbiwgXG4gIGFkZERvYywgXG4gIGdldERvY3MsIFxuICBkb2MsIFxuICB1cGRhdGVEb2MsIFxuICBkZWxldGVEb2MsIFxuICBxdWVyeSwgXG4gIHdoZXJlLCBcbiAgb3JkZXJCeSxcbiAgVGltZXN0YW1wLFxuICBEb2N1bWVudERhdGEsXG4gIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCxcbiAgRmlyZXN0b3JlRXJyb3Jcbn0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJ1xuaW1wb3J0IHsgZ2V0U3RvcmFnZSB9IGZyb20gJ2ZpcmViYXNlL3N0b3JhZ2UnXG5cblxuLy8gQWRkIHRoZXNlIHR5cGVzIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUgYWZ0ZXIgdGhlIGltcG9ydHNcblxuaW50ZXJmYWNlIEFwcGxpY2F0aW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgY3JlYXRlZEF0OiBzdHJpbmcgfCBUaW1lc3RhbXA7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBldmVudElkOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmNvbnN0IGZpcmViYXNlQ29uZmlnID0ge1xuICBhcGlLZXk6IFwiQUl6YVN5Q2lKRlNxM19zeTR3RE4yUW5jYU55cU8xTWxTbXREbjJRXCIsXG4gIGF1dGhEb21haW46IFwidm9sdW50ZWVyLWE2MWQzLmZpcmViYXNlYXBwLmNvbVwiLFxuICBwcm9qZWN0SWQ6IFwidm9sdW50ZWVyLWE2MWQzXCIsXG4gIHN0b3JhZ2VCdWNrZXQ6IFwidm9sdW50ZWVyLWE2MWQzLmZpcmViYXNlc3RvcmFnZS5hcHBcIixcbiAgbWVzc2FnaW5nU2VuZGVySWQ6IFwiNzgzNzUzNTg2ODY1XCIsXG4gIGFwcElkOiBcIjE6NzgzNzUzNTg2ODY1OndlYjo4NGEzZjA3MWUzM2E0OTM0ZGE5YTkwXCIsXG4gIG1lYXN1cmVtZW50SWQ6IFwiRy1GMlc4VFM3R0I5XCJcbn07XG5cbmNvbnN0IGFwcCA9IGluaXRpYWxpemVBcHAoZmlyZWJhc2VDb25maWcpXG5leHBvcnQgY29uc3QgYXV0aCA9IGdldEF1dGgoYXBwKVxuZXhwb3J0IGNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGFwcClcbmV4cG9ydCBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShhcHApXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IEZpcmVzdG9yZSB0aW1lc3RhbXBzXG4vLyBSZXBsYWNlIHRoZSBleGlzdGluZyBjb252ZXJ0VGltZXN0YW1wIGZ1bmN0aW9uXG5cbmNvbnN0IGNvbnZlcnRUaW1lc3RhbXAgPSAoZGF0YTogRG9jdW1lbnREYXRhKSA9PiB7XG4gIGNvbnN0IGNvbnZlcnRlZCA9IHsgLi4uZGF0YSB9XG4gIE9iamVjdC5rZXlzKGNvbnZlcnRlZCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChjb252ZXJ0ZWRba2V5XSBpbnN0YW5jZW9mIFRpbWVzdGFtcCkge1xuICAgICAgY29udmVydGVkW2tleV0gPSBjb252ZXJ0ZWRba2V5XS50b0RhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdjcmVhdGVkQXQnICYmICFjb252ZXJ0ZWRba2V5XSkge1xuICAgICAgLy8gRW5zdXJlIGNyZWF0ZWRBdCBhbHdheXMgaGFzIGEgdmFsdWVcbiAgICAgIGNvbnZlcnRlZFtrZXldID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfVxuICB9KVxuICByZXR1cm4gY29udmVydGVkXG59XG5cbi8vIEV2ZW50IGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUV2ZW50ID0gYXN5bmMgKGV2ZW50RGF0YTogYW55KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGV2ZW50IHdpdGggZGF0YTonLCBldmVudERhdGEpXG4gICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdldmVudHMnKSwge1xuICAgICAgLi4uZXZlbnREYXRhLFxuICAgICAgY3JlYXRlZEF0OiBUaW1lc3RhbXAubm93KCksXG4gICAgICB1cGRhdGVkQXQ6IFRpbWVzdGFtcC5ub3coKVxuICAgIH0pXG4gICAgY29uc29sZS5sb2coJ0V2ZW50IGNyZWF0ZWQgd2l0aCBJRDonLCBkb2NSZWYuaWQpXG4gICAgcmV0dXJuIGRvY1JlZlxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGV2ZW50OicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldEV2ZW50cyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYWxsIGV2ZW50cy4uLicpXG4gICAgY29uc3QgcSA9IHF1ZXJ5KGNvbGxlY3Rpb24oZGIsICdldmVudHMnKSwgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKSlcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKVxuICAgIGNvbnN0IGV2ZW50cyA9IHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICBpZDogZG9jLmlkLFxuICAgICAgLi4uY29udmVydFRpbWVzdGFtcChkb2MuZGF0YSgpKVxuICAgIH0pKVxuICAgIGNvbnNvbGUubG9nKCdFdmVudHMgZmV0Y2hlZDonLCBldmVudHMubGVuZ3RoKVxuICAgIHJldHVybiBldmVudHNcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBldmVudHM6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0RXZlbnRzQnlPd25lciA9IGFzeW5jIChvd25lcklkOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgZXZlbnRzIGZvciBvd25lcjonLCBvd25lcklkKVxuICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICdldmVudHMnKSwgXG4gICAgICB3aGVyZSgnb3duZXJJZCcsICc9PScsIG93bmVySWQpLFxuICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKVxuICAgIClcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKVxuICAgIGNvbnN0IGV2ZW50cyA9IHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICBpZDogZG9jLmlkLFxuICAgICAgLi4uY29udmVydFRpbWVzdGFtcChkb2MuZGF0YSgpKVxuICAgIH0pKVxuICAgIGNvbnNvbGUubG9nKGBFdmVudHMgZmV0Y2hlZCBmb3Igb3duZXIgJHtvd25lcklkfTpgLCBldmVudHMubGVuZ3RoKVxuICAgIHJldHVybiBldmVudHNcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBldmVudHMgYnkgb3duZXI6JywgZXJyb3IpXG4gICAgLy8gRml4OiBQcm9wZXIgdHlwZSBjaGVja2luZyBmb3IgRmlyZXN0b3JlRXJyb3JcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IgJiYgKGVycm9yIGFzIEZpcmVzdG9yZUVycm9yKS5jb2RlID09PSAnZmFpbGVkLXByZWNvbmRpdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXRyeWluZyB3aXRob3V0IG9yZGVyQnkgZHVlIHRvIG1pc3NpbmcgaW5kZXguLi4nKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIsICdldmVudHMnKSwgXG4gICAgICAgICAgd2hlcmUoJ293bmVySWQnLCAnPT0nLCBvd25lcklkKVxuICAgICAgICApXG4gICAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgICAuLi5jb252ZXJ0VGltZXN0YW1wKGRvYy5kYXRhKCkpXG4gICAgICAgIH0pKVxuICAgICAgICAvLyBTb3J0IG1hbnVhbGx5IGJ5IGNyZWF0ZWRBdFxuICAgICAgICBldmVudHMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5jcmVhdGVkQXQgYXMgc3RyaW5nKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmNyZWF0ZWRBdCBhcyBzdHJpbmcpLmdldFRpbWUoKSlcbiAgICAgICAgY29uc29sZS5sb2coYEV2ZW50cyBmZXRjaGVkIGZvciBvd25lciAke293bmVySWR9ICh3aXRob3V0IGluZGV4KTpgLCBldmVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZXZlbnRzXG4gICAgICB9IGNhdGNoIChyZXRyeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JldHJ5IGZhaWxlZDonLCByZXRyeUVycm9yKVxuICAgICAgICB0aHJvdyByZXRyeUVycm9yXG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUV2ZW50ID0gYXN5bmMgKGV2ZW50SWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYFVwZGF0aW5nIGV2ZW50ICR7ZXZlbnRJZH06YCwgdXBkYXRlcylcbiAgICBjb25zdCBldmVudFJlZiA9IGRvYyhkYiwgJ2V2ZW50cycsIGV2ZW50SWQpXG4gICAgYXdhaXQgdXBkYXRlRG9jKGV2ZW50UmVmLCB7XG4gICAgICAuLi51cGRhdGVzLFxuICAgICAgdXBkYXRlZEF0OiBUaW1lc3RhbXAubm93KClcbiAgICB9KVxuICAgIGNvbnNvbGUubG9nKGBFdmVudCAke2V2ZW50SWR9IHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5YClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBldmVudDonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVFdmVudCA9IGFzeW5jIChldmVudElkOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnRGVsZXRpbmcgZXZlbnQ6JywgZXZlbnRJZClcbiAgICBhd2FpdCBkZWxldGVEb2MoZG9jKGRiLCAnZXZlbnRzJywgZXZlbnRJZCkpXG4gICAgY29uc29sZS5sb2coYEV2ZW50ICR7ZXZlbnRJZH0gZGVsZXRlZCBzdWNjZXNzZnVsbHlgKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGV2ZW50OicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gQXBwbGljYXRpb24gZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgY3JlYXRlQXBwbGljYXRpb24gPSBhc3luYyAoYXBwbGljYXRpb25EYXRhOiBhbnkpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgYXBwbGljYXRpb24gd2l0aCBkYXRhOicsIGFwcGxpY2F0aW9uRGF0YSlcbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ2FwcGxpY2F0aW9ucycpLCB7XG4gICAgICAuLi5hcHBsaWNhdGlvbkRhdGEsXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIGNyZWF0ZWRBdDogVGltZXN0YW1wLm5vdygpXG4gICAgfSlcbiAgICBjb25zb2xlLmxvZygnQXBwbGljYXRpb24gY3JlYXRlZCB3aXRoIElEOicsIGRvY1JlZi5pZClcbiAgICByZXR1cm4gZG9jUmVmXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgYXBwbGljYXRpb246JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25zQnlFdmVudCA9IGFzeW5jIChldmVudElkOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYXBwbGljYXRpb25zIGZvciBldmVudDonLCBldmVudElkKVxuICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICdhcHBsaWNhdGlvbnMnKSxcbiAgICAgIHdoZXJlKCdldmVudElkJywgJz09JywgZXZlbnRJZClcbiAgICApXG4gICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSlcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmNvbnZlcnRUaW1lc3RhbXAoZG9jLmRhdGEoKSlcbiAgICB9KSlcbiAgICBjb25zb2xlLmxvZyhgQXBwbGljYXRpb25zIGZldGNoZWQgZm9yIGV2ZW50ICR7ZXZlbnRJZH06YCwgYXBwbGljYXRpb25zLmxlbmd0aClcbiAgICByZXR1cm4gYXBwbGljYXRpb25zXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXBwbGljYXRpb25zIGJ5IGV2ZW50OicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldEFwcGxpY2F0aW9uc0J5VXNlciA9IGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhcHBsaWNhdGlvbnMgZm9yIHVzZXI6JywgdXNlcklkKVxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIG9yZGVyQnlcbiAgICB0cnkge1xuICAgICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgICBjb2xsZWN0aW9uKGRiLCAnYXBwbGljYXRpb25zJyksXG4gICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxuICAgICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgICApXG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKVxuICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgLi4uY29udmVydFRpbWVzdGFtcChkb2MuZGF0YSgpKVxuICAgICAgfSkpXG4gICAgICBjb25zb2xlLmxvZyhgQXBwbGljYXRpb25zIGZldGNoZWQgZm9yIHVzZXIgJHt1c2VySWR9OmAsIGFwcGxpY2F0aW9ucy5sZW5ndGgpXG4gICAgICByZXR1cm4gYXBwbGljYXRpb25zXG4gICAgfSBjYXRjaCAoaW5kZXhFcnJvcikge1xuICAgICAgLy8gRml4OiBQcm9wZXIgdHlwZSBjaGVja2luZyBmb3IgRmlyZXN0b3JlRXJyb3JcbiAgICAgIGlmIChpbmRleEVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGluZGV4RXJyb3IgJiYgKGluZGV4RXJyb3IgYXMgRmlyZXN0b3JlRXJyb3IpLmNvZGUgPT09ICdmYWlsZWQtcHJlY29uZGl0aW9uJykge1xuICAgICAgICBjb25zb2xlLmxvZygnSW5kZXggbm90IGZvdW5kLCBmZXRjaGluZyB3aXRob3V0IG9yZGVyQnkgYW5kIHNvcnRpbmcgbWFudWFsbHkuLi4nKVxuICAgICAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICAgICAgY29sbGVjdGlvbihkYiwgJ2FwcGxpY2F0aW9ucycpLFxuICAgICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSlcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAgIC4uLmNvbnZlcnRUaW1lc3RhbXAoZG9jLmRhdGEoKSlcbiAgICAgICAgfSkpXG4gICAgICAgIFxuICAgICAgICAvLyBGaXg6IFByb3BlciB0eXBlIGFzc2VydGlvbiBmb3IgZGF0ZSBzdHJpbmdzXG4gICAgICAgIGFwcGxpY2F0aW9ucy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0ZUEgPSBuZXcgRGF0ZShhLmNyZWF0ZWRBdCBhcyBzdHJpbmcpLmdldFRpbWUoKVxuICAgICAgICAgIGNvbnN0IGRhdGVCID0gbmV3IERhdGUoYi5jcmVhdGVkQXQgYXMgc3RyaW5nKS5nZXRUaW1lKClcbiAgICAgICAgICByZXR1cm4gZGF0ZUIgLSBkYXRlQVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEFwcGxpY2F0aW9ucyBmZXRjaGVkIGZvciB1c2VyICR7dXNlcklkfSAobWFudWFsIHNvcnQpOmAsIGFwcGxpY2F0aW9ucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBhcHBsaWNhdGlvbnNcbiAgICAgIH1cbiAgICAgIHRocm93IGluZGV4RXJyb3JcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXBwbGljYXRpb25zIGJ5IHVzZXI6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlQXBwbGljYXRpb25TdGF0dXMgPSBhc3luYyAoYXBwbGljYXRpb25JZDogc3RyaW5nLCBzdGF0dXM6ICdhcHByb3ZlZCcgfCAnZGVjbGluZWQnKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYFVwZGF0aW5nIGFwcGxpY2F0aW9uICR7YXBwbGljYXRpb25JZH0gc3RhdHVzIHRvOmAsIHN0YXR1cylcbiAgICBjb25zdCBhcHBsaWNhdGlvblJlZiA9IGRvYyhkYiwgJ2FwcGxpY2F0aW9ucycsIGFwcGxpY2F0aW9uSWQpXG4gICAgYXdhaXQgdXBkYXRlRG9jKGFwcGxpY2F0aW9uUmVmLCB7XG4gICAgICBzdGF0dXMsXG4gICAgICB1cGRhdGVkQXQ6IFRpbWVzdGFtcC5ub3coKVxuICAgIH0pXG4gICAgY29uc29sZS5sb2coYEFwcGxpY2F0aW9uICR7YXBwbGljYXRpb25JZH0gc3RhdHVzIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5YClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBhcHBsaWNhdGlvbiBzdGF0dXM6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBEZWJ1ZyBmdW5jdGlvbiB0byBjaGVjayBjb2xsZWN0aW9uc1xuZXhwb3J0IGNvbnN0IGRlYnVnQ29sbGVjdGlvbnMgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJz09PSBERUJVRzogQ2hlY2tpbmcgY29sbGVjdGlvbnMgPT09JylcbiAgICBcbiAgICAvLyBDaGVjayBldmVudHMgY29sbGVjdGlvblxuICAgIGNvbnN0IGV2ZW50c1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsZWN0aW9uKGRiLCAnZXZlbnRzJykpXG4gICAgY29uc29sZS5sb2coJ0V2ZW50cyBjb2xsZWN0aW9uIHNpemU6JywgZXZlbnRzU25hcHNob3Quc2l6ZSlcbiAgICBldmVudHNTbmFwc2hvdC5kb2NzLmZvckVhY2goZG9jID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdFdmVudDonLCBkb2MuaWQsIGRvYy5kYXRhKCkpXG4gICAgfSlcbiAgICBcbiAgICAvLyBDaGVjayBhcHBsaWNhdGlvbnMgY29sbGVjdGlvblxuICAgIGNvbnN0IGFwcGxpY2F0aW9uc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsZWN0aW9uKGRiLCAnYXBwbGljYXRpb25zJykpXG4gICAgY29uc29sZS5sb2coJ0FwcGxpY2F0aW9ucyBjb2xsZWN0aW9uIHNpemU6JywgYXBwbGljYXRpb25zU25hcHNob3Quc2l6ZSlcbiAgICBhcHBsaWNhdGlvbnNTbmFwc2hvdC5kb2NzLmZvckVhY2goZG9jID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBcHBsaWNhdGlvbjonLCBkb2MuaWQsIGRvYy5kYXRhKCkpXG4gICAgfSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygnPT09IEVORCBERUJVRyA9PT0nKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0RlYnVnIGVycm9yOicsIGVycm9yKVxuICB9XG59Il0sIm5hbWVzIjpbImluaXRpYWxpemVBcHAiLCJnZXRBdXRoIiwiZ2V0RmlyZXN0b3JlIiwiY29sbGVjdGlvbiIsImFkZERvYyIsImdldERvY3MiLCJkb2MiLCJ1cGRhdGVEb2MiLCJkZWxldGVEb2MiLCJxdWVyeSIsIndoZXJlIiwib3JkZXJCeSIsIlRpbWVzdGFtcCIsImdldFN0b3JhZ2UiLCJmaXJlYmFzZUNvbmZpZyIsImFwaUtleSIsImF1dGhEb21haW4iLCJwcm9qZWN0SWQiLCJzdG9yYWdlQnVja2V0IiwibWVzc2FnaW5nU2VuZGVySWQiLCJhcHBJZCIsIm1lYXN1cmVtZW50SWQiLCJhcHAiLCJhdXRoIiwiZGIiLCJzdG9yYWdlIiwiY29udmVydFRpbWVzdGFtcCIsImRhdGEiLCJjb252ZXJ0ZWQiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInRvRGF0ZSIsInRvSVNPU3RyaW5nIiwiRGF0ZSIsImNyZWF0ZUV2ZW50IiwiZXZlbnREYXRhIiwiY29uc29sZSIsImxvZyIsImRvY1JlZiIsImNyZWF0ZWRBdCIsIm5vdyIsInVwZGF0ZWRBdCIsImlkIiwiZXJyb3IiLCJnZXRFdmVudHMiLCJxIiwicXVlcnlTbmFwc2hvdCIsImV2ZW50cyIsImRvY3MiLCJtYXAiLCJsZW5ndGgiLCJnZXRFdmVudHNCeU93bmVyIiwib3duZXJJZCIsIkVycm9yIiwiY29kZSIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJyZXRyeUVycm9yIiwidXBkYXRlRXZlbnQiLCJldmVudElkIiwidXBkYXRlcyIsImV2ZW50UmVmIiwiZGVsZXRlRXZlbnQiLCJjcmVhdGVBcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uRGF0YSIsInN0YXR1cyIsImdldEFwcGxpY2F0aW9uc0J5RXZlbnQiLCJhcHBsaWNhdGlvbnMiLCJnZXRBcHBsaWNhdGlvbnNCeVVzZXIiLCJ1c2VySWQiLCJpbmRleEVycm9yIiwiZGF0ZUEiLCJkYXRlQiIsInVwZGF0ZUFwcGxpY2F0aW9uU3RhdHVzIiwiYXBwbGljYXRpb25JZCIsImFwcGxpY2F0aW9uUmVmIiwiZGVidWdDb2xsZWN0aW9ucyIsImV2ZW50c1NuYXBzaG90Iiwic2l6ZSIsImFwcGxpY2F0aW9uc1NuYXBzaG90Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firebase.ts\n"));

/***/ })

});